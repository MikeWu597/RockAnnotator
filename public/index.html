<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图像标注工具 - RockAnnotator</title>
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/css/all.min.css">
    <style>
        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #canvas-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 60px);
            overflow: hidden;
            background-color: #f0f0f0;
        }
        
        #imageCanvas {
            position: absolute;
            cursor: crosshair;
        }
        
        #toolbar {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }
        
        .toolbar-item {
            margin: 5px 0;
        }
        
        .instructions {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 5px;
            padding: 10px;
            font-size: 14px;
        }
        
        .status-bar {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 5px;
            padding: 10px;
            font-size: 14px;
        }
        
        .polygon-point {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
        
        .polygon-line {
            position: absolute;
            height: 2px;
            background-color: red;
            transform-origin: 0 0;
            pointer-events: none;
            z-index: 9;
        }
    </style>
</head>
<body>
    <div id="loading" class="d-flex justify-content-center align-items-center" style="height: 100vh;">
        <div>
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">加载中...</span>
            </div>
            <p class="mt-2">正在加载标注任务...</p>
        </div>
    </div>
    
    <div id="main-content" style="display: none;">
        <div id="canvas-container">
            <canvas id="imageCanvas"></canvas>
        </div>
        
        <div id="toolbar">
            <div class="toolbar-item">
                <button id="zoomInBtn" class="btn btn-sm btn-outline-primary" title="放大">
                    <i class="fas fa-search-plus"></i> 放大
                </button>
            </div>
            <div class="toolbar-item">
                <button id="zoomOutBtn" class="btn btn-sm btn-outline-primary" title="缩小">
                    <i class="fas fa-search-minus"></i> 缩小
                </button>
            </div>
            <div class="toolbar-item">
                <button id="resetViewBtn" class="btn btn-sm btn-outline-secondary" title="重置视图">
                    <i class="fas fa-expand"></i> 铺满
                </button>
            </div>
            <div class="toolbar-item">
                <button id="clearPolygonBtn" class="btn btn-sm btn-outline-warning" title="清除当前多边形">
                    <i class="fas fa-undo"></i> 撤销
                </button>
            </div>
            <div class="toolbar-item">
                <button id="saveBtn" class="btn btn-sm btn-success" title="保存标注 (或按任意键)">
                    <i class="fas fa-save"></i> 保存
                </button>
            </div>
            <div class="toolbar-item">
                <div style="display:flex;align-items:center;gap:6px;">
                    <div id="annotatorIcon" style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;color:#333;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 12c2.7 0 4.8-2.1 4.8-4.8S14.7 2.4 12 2.4 7.2 4.5 7.2 7.2 9.3 12 12 12zm0 2.4c-3.2 0-9.6 1.6-9.6 4.8V22h19.2v-2.8c0-3.2-6.4-4.8-9.6-4.8z"/></svg>
                    </div>
                    <div id="annotatorName" style="font-size:12px;color:#333;max-width:140px;word-break:break-all;"></div>
                </div>
            </div>
            <div class="toolbar-item">
                <div id="annotatorThumbs" style="display:flex;flex-direction:column;gap:6px;overflow-y:visible;max-height:none;width:64px;padding-top:6px;"></div>
            </div>
            <div class="toolbar-item">
                <button id="logoutBtn" class="btn btn-sm btn-outline-danger" title="退出登录">
                    <i class="fas fa-sign-out-alt"></i> 退出
                </button>
            </div>
        </div>
        
        <div class="instructions">
            <strong>使用说明:</strong><br>
            • 使用鼠标滚轮缩放图片<br>
            • 点击左键绘制多边形顶点<br>
            • 首尾相接完成多边形绘制<br>
            • 按任意键保存标注并加载新图片
        </div>
        
        <div class="status-bar">
            <div>当前任务ID: <span id="taskId">-</span></div>
            <div>已绘制多边形: <span id="polygonCount">0</span></div>
            <div>缩放比例: <span id="zoomLevel">100%</span></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // 全局变量
        let canvas = document.getElementById('imageCanvas');
        let ctx = canvas.getContext('2d');
        let currentImage = null;
        let currentTaskId = null;
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        // 最近一次鼠标在画布上的位置（用于工具按钮缩放时作为中心）
        let lastMouseCanvasX = 0;
        let lastMouseCanvasY = 0;
        // 最近一次鼠标对应的图片坐标（用于工具按钮缩放，保证缩放以同一图片点为中心）
        let lastMouseImageX = undefined;
        let lastMouseImageY = undefined;
        let polygons = []; // 存储已完成的多边形（图片坐标）
        let currentPolygon = []; // 存储当前正在绘制的多边形顶点（图片坐标）
        let isDrawing = false;
        
        // 页面加载完成后初始化
        window.addEventListener('load', function() {
            console.log('Page loaded, initializing application');
            // 检查标注员会话，未登录则跳转到标注员登录页面
            fetch('/api/annotator/session')
                .then(r => r.json())
                .then(j => {
                    if (!j || !j.success) {
                        // 若接口异常，仍尝试登录页面
                        window.location.href = '/annotator/login';
                        return;
                    }
                    if (!j.data) {
                        window.location.href = '/annotator/login';
                        return;
                    }
                    // 已登录，继续初始化：先绑定事件，再加载缩略图栏，启动缩略图自动刷新，最后加载任务
                    try {
                        setupEventListeners();
                        // 显示标注员用户名（如果有）
                        const an = document.getElementById('annotatorName');
                        if (an && j.data && j.data.username) an.textContent = j.data.username;
                        loadAnnotatorThumbnails();
                        startThumbnailsAutoRefresh();
                        // 启动心跳（每 20 秒上报）并在页面关闭时通知服务器释放分配
                        startAnnotatorHeartbeat();
                        loadRandomTask();
                    } catch (e) {
                        showError('初始化应用程序时发生错误: ' + e.message);
                    }
                })
                .catch(err => {
                    console.error('Session check failed', err);
                    window.location.href = '/annotator/login';
                });
        });
        
        // 加载随机标注任务
        function loadRandomTask() {
            console.log('Loading random task');
            try {
                fetch('/api/tasks/random')
                    .then(response => {
                        console.log('Received response from server');
                        return response.json();
                    })
                    .then(data => {
                        console.log('Received task data:', data);
                        if (data.success) {
                            currentTaskId = data.data.task.id;
                            document.getElementById('taskId').textContent = currentTaskId;
                            console.log('Loading image:', data.data.imagePath);
                            loadImage(data.data.imagePath);
                        } else {
                            console.log('No pending tasks available');
                            hideLoadingShowMessage(`
                                <div class="text-center">
                                    <i class="fas fa-exclamation-triangle text-warning" style="font-size: 3rem;"></i>
                                    <p class="mt-3">暂无待标注任务</p>
                                </div>
                            `);
                        }
                    })
                    .catch(error => {
                        console.error('Error loading task:', error);
                        hideLoadingShowMessage(`
                            <div class="text-center text-danger">
                                <i class="fas fa-exclamation-triangle" style="font-size: 3rem;"></i>
                                <p class="mt-3">加载任务失败: ${error.message}</p>
                                <button class="btn btn-primary mt-2" onclick="loadRandomTask()">重试</button>
                            </div>
                        `);
                    });
            } catch (e) {
                showError('加载任务时发生错误: ' + e.message);
            }
        }

        // 加载并渲染当前标注员已标注的缩略图（点击可跳回编辑）
        async function loadAnnotatorThumbnails() {
            try {
                // 只取最新 5 条
                const resp = await fetch('/api/annotator/annotations?page=1&pageSize=5');
                const j = await resp.json().catch(()=>null);
                const container = document.getElementById('annotatorThumbs');
                if (!container) return;
                container.innerHTML = '';
                if (!resp.ok || !j || !j.success) return;
                const list = (j.data && j.data.annotations) || [];
                // 去重：按 taskId 去重，保留列表中最先出现（服务器通常按时间降序返回最新的在前）
                const unique = [];
                const seen = new Set();
                for (const item of list) {
                    if (!item || !item.filename) continue;
                    const key = (item.taskId !== undefined && item.taskId !== null) ? String(item.taskId) : (item.filename || '');
                    if (seen.has(key)) continue;
                    seen.add(key);
                    unique.push(item);
                    if (unique.length >= 5) break; // 只保留最多 5 个
                }

                unique.forEach(item => {
                    const wrapper = document.createElement('div');
                    wrapper.style.display = 'flex';
                    wrapper.style.flexDirection = 'column';
                    wrapper.style.alignItems = 'center';
                    wrapper.style.cursor = 'pointer';

                    const img = document.createElement('img');
                    img.src = '/uploads/' + encodeURI(item.filename);
                    img.style.width = '56px';
                    img.style.height = '56px';
                    img.style.objectFit = 'cover';
                    img.style.border = '1px solid rgba(0,0,0,0.08)';
                    img.alt = `任务 ${item.taskId}`;

                    const time = document.createElement('small');
                    time.style.fontSize = '10px';
                    time.style.color = '#666';
                    time.textContent = item.created_at ? new Date(item.created_at).toLocaleTimeString() : '';

                    wrapper.addEventListener('click', function(){ if (item.taskId) loadTaskForEditing(item.taskId); });
                    wrapper.appendChild(img);
                    wrapper.appendChild(time);
                    container.appendChild(wrapper);
                });
            } catch (e) { console.error('加载缩略图失败', e); }
        }

        // 跳回指定任务进行编辑：加载图片并应用最后一次标注的多边形
        async function loadTaskForEditing(taskId) {
            if (!taskId) return alert('无效的任务ID');
            try {
                const resp = await fetch(`/api/tasks/${taskId}`);
                const j = await resp.json().catch(()=>null);
                if (!resp.ok || !j || !j.success) { alert('无法加载任务：' + (j && j.error ? j.error : '未知错误')); return; }
                const data = j.data || {};
                const imagePath = data.imagePath;
                const annotations = data.annotations || [];
                currentTaskId = taskId;
                document.getElementById('taskId').textContent = currentTaskId;
                // 取最后一条标注的 polygons
                let newPolygons = [];
                if (annotations && annotations.length > 0) {
                    const last = annotations[annotations.length - 1];
                    if (last && last.polygons) newPolygons = last.polygons;
                }
                currentPolygon = [];
                // loadImage returns a promise
                await loadImage(imagePath);
                polygons = Array.isArray(newPolygons) ? newPolygons : [];
                drawImage();
                updatePolygonCount();
            } catch (e) {
                console.error('跳转编辑任务失败', e);
                alert('跳转编辑任务失败: ' + (e.message || e));
            }
        }

        // 实时刷新缩略图（每 8 秒）
        let _thumbsInterval = null;
        function startThumbnailsAutoRefresh() {
            if (_thumbsInterval) return;
            _thumbsInterval = setInterval(() => { loadAnnotatorThumbnails(); }, 8000);
        }
        function stopThumbnailsAutoRefresh() {
            if (_thumbsInterval) { clearInterval(_thumbsInterval); _thumbsInterval = null; }
        }

        // 标注员心跳：页面打开时定期上报，页面关闭时释放分配
        let _heartbeatInterval = null;
        function startAnnotatorHeartbeat() {
            if (_heartbeatInterval) return;
            // 立即发送一次心跳
            sendAnnotatorHeartbeat();
            _heartbeatInterval = setInterval(sendAnnotatorHeartbeat, 20000);
            // 在页面卸载时尝试通知服务器释放分配（使用 sendBeacon 优先）
            window.addEventListener('beforeunload', function() {
                try {
                    const url = '/api/annotator/close';
                    if (navigator.sendBeacon) {
                        navigator.sendBeacon(url, '');
                    } else {
                        // fetch keepalive
                        fetch(url, { method: 'POST', keepalive: true });
                    }
                } catch (e) { /* ignore */ }
            });
        }

        function stopAnnotatorHeartbeat() {
            if (_heartbeatInterval) { clearInterval(_heartbeatInterval); _heartbeatInterval = null; }
        }

        function sendAnnotatorHeartbeat() {
            try {
                fetch('/api/annotator/heartbeat', { method: 'POST' }).catch(()=>{});
            } catch (e) { /* ignore */ }
        }
        
        // 隐藏加载界面并显示消息
        function hideLoadingShowMessage(message) {
            const loadingElement = document.getElementById('loading');
            if (loadingElement) {
                loadingElement.innerHTML = message;
                loadingElement.style.display = 'block';
            }
            const mainContentElement = document.getElementById('main-content');
            if (mainContentElement) {
                mainContentElement.style.display = 'none';
            }
        }
        
        // 显示错误消息
        function showError(message) {
            console.error('Application error:', message);
            hideLoadingShowMessage(`
                <div class="text-center text-danger">
                    <i class="fas fa-exclamation-triangle" style="font-size: 3rem;"></i>
                    <p class="mt-3">${message}</p>
                    <button class="btn btn-primary mt-2" onclick="location.reload()">重新加载</button>
                </div>
            `);
        }
        
        // 加载图片
        function loadImage(imagePath) {
            try {
                console.log('Loading image with path:', imagePath);
                
                // 先显示加载中界面
                const loadingElement = document.getElementById('loading');
                const mainContentElement = document.getElementById('main-content');
                
                if (loadingElement) {
                    loadingElement.style.display = 'flex';
                    loadingElement.innerHTML = `
                        <div>
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">加载中...</span>
                            </div>
                            <p class="mt-2">正在加载图片...</p>
                        </div>
                    `;
                }
                
                if (mainContentElement) {
                    mainContentElement.style.display = 'none';
                }
                
                // 创建新的图片对象
                const img = new Image();
                
                // 设置跨域属性（如果需要）
                img.crossOrigin = "anonymous";
                
                img.onload = function() {
                    try {
                        console.log('Image loaded successfully:', img.width, 'x', img.height);
                        currentImage = img;

                        // 确保画布大小并绘制（优先重设画布以防尺寸为0）
                        resizeCanvas();
                        drawImage();
                        updateZoomLevel();

                        // 稳健地隐藏加载遮罩（使用 !important 覆盖任何 CSS），并清空其内容以避免再次被设置为可见
                        if (loadingElement) {
                            loadingElement.style.setProperty('display', 'none', 'important');
                            loadingElement.style.setProperty('visibility', 'hidden', 'important');
                            loadingElement.style.setProperty('pointer-events', 'none', 'important');
                            loadingElement.innerHTML = '';
                        }

                        // 确保主内容可见
                        if (mainContentElement) {
                            mainContentElement.style.setProperty('display', 'block', 'important');
                            mainContentElement.style.setProperty('visibility', 'visible', 'important');
                        }

                        // 如果在某些浏览器/布局下仍未显示，强制重绘，并滚动到画布中心
                        setTimeout(() => {
                            resizeCanvas();
                            drawImage();
                            // 将焦点聚到 canvas，防止被其他元素遮挡
                            canvas.scrollIntoView({behavior: 'auto', block: 'center'});
                        }, 50);

                        // resolve promise if caller awaited loadImage
                        try { if (typeof _loadImageResolve === 'function') _loadImageResolve(); } catch(_) {}
                    } catch (e) {
                        showError('绘制图片时发生错误: ' + e.message);
                    }
                };
                
                img.onerror = function(event) {
                    console.error('图片加载失败:', imagePath, event);
                    hideLoadingShowMessage(`
                        <div class="text-center text-danger">
                            <i class="fas fa-exclamation-triangle" style="font-size: 3rem;"></i>
                            <p class="mt-3">图片加载失败: ${imagePath}</p>
                            <button class="btn btn-primary mt-2" onclick="loadRandomTask()">重试</button>
                        </div>
                    `);
                };
                
                // 正确处理图片路径并进行 URL 编码，避免空格/特殊字符导致的问题
                let resolvedSrc;
                if (imagePath.startsWith('/')) {
                    // 以 / 开头的路径，前面加上 . 表示相对于当前域的根目录
                    resolvedSrc = '.' + encodeURI(imagePath);
                } else if (imagePath.startsWith('http')) {
                    // 完整 URL 直接使用
                    resolvedSrc = imagePath;
                } else {
                    // 相对路径进行编码
                    resolvedSrc = encodeURI(imagePath);
                }
                img.src = resolvedSrc;
                // 返回一个 promise，允许调用者等待图片加载完成
                return new Promise((resolve, reject) => {
                    // 临时挂载 resolve，用于 onload 回调触发
                    window._loadImageResolve = () => { window._loadImageResolve = null; resolve(); };
                    // onerror 时清理并 reject
                    const prevOnError = img.onerror;
                    img.onerror = function(ev) {
                        try { window._loadImageResolve = null; } catch(_) {}
                        prevOnError && prevOnError(ev);
                        reject(new Error('图片加载失败'));
                    };
                });
                console.log('Final image src:', img.src, 'img.complete:', img.complete);
                // 调试：如果若干秒后还未加载，输出警告便于定位
                setTimeout(() => {
                    if (!img.complete) {
                        console.warn('Image not loaded after 5s. src=', img.src);
                    }
                }, 5000);
            } catch (e) {
                showError('加载图片时发生错误: ' + e.message);
            }
        }
        
        // 调整画布大小
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            drawImage(); // 重新绘制图像
        }
        
        // 绘制图片
        function drawImage() {
            // 检查是否有图片需要绘制
            if (!currentImage) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 计算居中位置
            const imageWidth = currentImage.width * scale;
            const imageHeight = currentImage.height * scale;
            const x = (canvas.width - imageWidth) / 2 + offsetX;
            const y = (canvas.height - imageHeight) / 2 + offsetY;
            
            // 绘制图片
            ctx.drawImage(currentImage, x, y, imageWidth, imageHeight);
            
            // 绘制已完成的多边形
            drawPolygons();
            
            // 绘制当前正在绘制的多边形
            drawCurrentPolygon();
        }
        
        // ----- 标签渲染辅助 -----
        function getTagColor(tag) {
            // 简单哈希到 H 值，保证不同 tag 颜色可区分
            let hash = 0;
            for (let i = 0; i < tag.length; i++) {
                hash = ((hash << 5) - hash) + tag.charCodeAt(i);
                hash |= 0;
            }
            const h = Math.abs(hash) % 360;
            return `hsl(${h}, 70%, 45%)`;
        }

        function drawRoundedRect(ctx, x, y, w, h, r) {
            r = Math.min(r, w/2, h/2);
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
            ctx.fill();
        }

        // 绘制已完成的多边形（polygons 存储为 {points:[], tag: ''}）
        function drawPolygons() {
            ctx.lineWidth = 2;
            ctx.fillStyle = 'rgba(255, 0, 0, 0.15)';
            ctx.strokeStyle = 'red';

            polygons.forEach(polygon => {
                if (!polygon.points || polygon.points.length < 3) return;

                ctx.beginPath();
                const first = imageToCanvasCoords(polygon.points[0].x, polygon.points[0].y);
                ctx.moveTo(first.x, first.y);

                for (let i = 1; i < polygon.points.length; i++) {
                    const pCanvas = imageToCanvasCoords(polygon.points[i].x, polygon.points[i].y);
                    ctx.lineTo(pCanvas.x, pCanvas.y);
                }

                ctx.closePath();
                ctx.stroke();
                ctx.fill();

                // 在多边形中心显示标签（带醒目背景色）
                if (polygon.tag) {
                    // 计算质心（图片坐标）并转换为画布坐标
                    const centroid = polygon.points.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), {x:0,y:0});
                    centroid.x /= polygon.points.length;
                    centroid.y /= polygon.points.length;
                    const cCanvas = imageToCanvasCoords(centroid.x, centroid.y);

                    // 文本与背景样式
                    ctx.save();
                    ctx.font = 'bold 12px sans-serif';
                    ctx.textBaseline = 'middle';
                    ctx.textAlign = 'left';
                    const padding = 6;
                    const text = polygon.tag;
                    const metrics = ctx.measureText(text);
                    const textW = metrics.width;
                    const rectW = textW + padding * 2;
                    const rectH = 18;

                    // 初始位置：位于质心右上方
                    let left = cCanvas.x + 6;
                    let top = cCanvas.y - 6 - rectH;

                    // 保证不超出画布边界
                    if (left + rectW + 4 > canvas.width) left = canvas.width - rectW - 4;
                    if (left < 4) left = 4;
                    if (top < 4) top = cCanvas.y + 6; // 如果顶部超出，则放到质心下方

                    // 背景色
                    const bg = getTagColor(text);
                    ctx.fillStyle = bg;
                    ctx.shadowColor = 'rgba(0,0,0,0.25)';
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 2;

                    // 绘制圆角背景
                    drawRoundedRect(ctx, left, top, rectW, rectH, 6);

                    // 绘制文本
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(text, left + padding, top + rectH / 2);
                    ctx.restore();
                }
            });
        }
        
        // 绘制当前正在绘制的多边形（currentPolygon 存储为图片坐标）
        function drawCurrentPolygon() {
            if (currentPolygon.length === 0) return;

            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'rgba(0, 0, 255, 0.3)';

            // 绘制顶点间的连线（转换为画布坐标后绘制）
            if (currentPolygon.length > 1) {
                ctx.beginPath();
                const first = imageToCanvasCoords(currentPolygon[0].x, currentPolygon[0].y);
                ctx.moveTo(first.x, first.y);

                for (let i = 1; i < currentPolygon.length; i++) {
                    const pCanvas = imageToCanvasCoords(currentPolygon[i].x, currentPolygon[i].y);
                    ctx.lineTo(pCanvas.x, pCanvas.y);
                }

                ctx.stroke();
            }

            // 绘制顶点
            currentPolygon.forEach(point => {
                const pCanvas = imageToCanvasCoords(point.x, point.y);
                ctx.beginPath();
                ctx.arc(pCanvas.x, pCanvas.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = 'blue';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // 如果至少有3个点，绘制预览填充区域（先将点转换为画布坐标）
            if (currentPolygon.length >= 3) {
                ctx.beginPath();
                const first = imageToCanvasCoords(currentPolygon[0].x, currentPolygon[0].y);
                ctx.moveTo(first.x, first.y);

                for (let i = 1; i < currentPolygon.length; i++) {
                    const pCanvas = imageToCanvasCoords(currentPolygon[i].x, currentPolygon[i].y);
                    ctx.lineTo(pCanvas.x, pCanvas.y);
                }

                // 连接最后一个点到第一个点
                ctx.closePath();
                ctx.fillStyle = 'rgba(0, 0, 255, 0.1)';
                ctx.fill();
            }
        }
        
        // 设置事件监听器
        function setupEventListeners() {
            // 窗口大小改变
            window.addEventListener('resize', function() {
                if (currentImage) {
                    resizeCanvas();
                }
            });
            
            // 鼠标事件
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            // wheel需要阻止默认滚动，设置 passive: false
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            // 自定义右键：在多边形内部显示内建菜单
            canvas.addEventListener('contextmenu', function(e) { e.preventDefault(); showPolygonContextMenu(e); });
            
            // 键盘事件
            document.addEventListener('keydown', handleKeyDown);
            
            // 工具栏按钮事件
            document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
            document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
            document.getElementById('resetViewBtn').addEventListener('click', resetView);
            document.getElementById('clearPolygonBtn').addEventListener('click', clearCurrentPolygon);
            document.getElementById('saveBtn').addEventListener('click', saveAndLoadNew);
            try { const lb = document.getElementById('logoutBtn'); if (lb) lb.addEventListener('click', () => { window.location.href = '/annotator/logout'; }); } catch(e) {}

            // 加载可用标签列表
            loadAvailableTags();
        }
        
        // 鼠标按下事件
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // 中键(1)或右键(2)用于平移
            if (e.button === 1 || e.button === 2) {
                isDragging = true;
                lastX = x;
                lastY = y;
                return;
            }

            // 只处理左键用于绘制顶点
            if (e.button !== 0) return;

            if (isNearFirstPoint(x, y) && currentPolygon.length >= 3) {
                // 完成多边形绘制
                finishPolygon();
            } else {
                // 将点转换为图片坐标后存储，这样缩放/平移时点会随图片同步变换
                const imgCoords = canvasToImageCoords(x, y);
                currentPolygon.push({x: imgCoords.x, y: imgCoords.y});
                drawImage();
                updatePolygonCount();
            }
        }
        
        // 鼠标移动事件
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // 保存最后的鼠标位置（用于工具栏缩放以最近鼠标位置为中心）
            lastMouseCanvasX = x;
            lastMouseCanvasY = y;
            // 同步记录对应的图片坐标，保证后续工具栏缩放使用的中心点跟随图片位置
            const imgPos = canvasToImageCoords(x, y);
            lastMouseImageX = imgPos.x;
            lastMouseImageY = imgPos.y;

            if (!isDragging) return;

            // 平移图片
            offsetX += (x - lastX);
            offsetY += (y - lastY);
            lastX = x;
            lastY = y;

            drawImage();
        }
        
        // 鼠标抬起事件
        function handleMouseUp(e) {
            isDragging = false;
        }

        // 鼠标离开画布时取消拖拽
        canvas.addEventListener('mouseleave', function() {
            isDragging = false;
        });
        
        // 缩放工具：以给定画布坐标为中心缩放（使用图片坐标计算，保证同一图片点保持在相同画布位置）
        function zoomAt(canvasX, canvasY, scaleFactor) {
            if (!currentImage) return;

            // 将画布坐标转换为图片坐标（基于当前变换）
            const imgPos = canvasToImageCoords(canvasX, canvasY);

            const oldScale = scale;
            const newScale = Math.max(0.1, Math.min(scale * scaleFactor, 10));

            // 计算在 newScale 下，图片左上角的画布位置
            const newImageWidth = currentImage.width * newScale;
            const newImageHeight = currentImage.height * newScale;

            // 直接根据图片坐标和目标画布坐标计算新的 offset，保证图片点 imgPos 在 canvasX,canvasY
            offsetX = canvasX - ((canvas.width - newImageWidth) / 2) - imgPos.x * newScale;
            offsetY = canvasY - ((canvas.height - newImageHeight) / 2) - imgPos.y * newScale;

            // 更新 scale
            scale = newScale;

            drawImage();
            updateZoomLevel();
        }

        // 鼠标滚轮事件（缩放），以鼠标位置对应的图片点为中心（先换算成图片坐标，保证缩放中心相对于图片不变）
        function handleWheel(e) {
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // 记录最近的鼠标位置（画布坐标）和对应的图片坐标，供工具按钮等使用
            lastMouseCanvasX = x;
            lastMouseCanvasY = y;
            const imgPos = canvasToImageCoords(x, y);
            lastMouseImageX = imgPos.x;
            lastMouseImageY = imgPos.y;

            // 更平滑的缩放因子，兼容鼠标滚轮和触控板
            const scaleFactor = Math.exp(-e.deltaY * 0.001);

            // 将图片坐标转换回画布坐标（在当前变换下），并以此为缩放中心
            const center = imageToCanvasCoords(imgPos.x, imgPos.y);
            zoomAt(center.x, center.y, scaleFactor);
        }
        
        // 键盘按下事件
        function handleKeyDown(e) {
            // 忽略修饰键
            if (e.ctrlKey || e.altKey || e.metaKey) return;
            
            // 保存并加载新任务
            saveAndLoadNew();
        }
        
        // 放大（以最近鼠标位置为中心，如果没有鼠标位置则以画布中心为中心）
        function zoomIn() {
            let centerX = canvas.width / 2;
            let centerY = canvas.height / 2;

            // 优先使用最近鼠标对应的图片坐标，确保缩放后的图片依旧以同一图片点为中心
            if (typeof lastMouseImageX === 'number' && typeof lastMouseImageY === 'number') {
                const p = imageToCanvasCoords(lastMouseImageX, lastMouseImageY);
                centerX = p.x;
                centerY = p.y;
            } else if (typeof lastMouseCanvasX === 'number' && typeof lastMouseCanvasY === 'number') {
                centerX = lastMouseCanvasX;
                centerY = lastMouseCanvasY;
            }

            zoomAt(centerX, centerY, 1.2);
        }

        // 缩小（以最近鼠标位置为中心）
        function zoomOut() {
            let centerX = canvas.width / 2;
            let centerY = canvas.height / 2;

            if (typeof lastMouseImageX === 'number' && typeof lastMouseImageY === 'number') {
                const p = imageToCanvasCoords(lastMouseImageX, lastMouseImageY);
                centerX = p.x;
                centerY = p.y;
            } else if (typeof lastMouseCanvasX === 'number' && typeof lastMouseCanvasY === 'number') {
                centerX = lastMouseCanvasX;
                centerY = lastMouseCanvasY;
            }

            zoomAt(centerX, centerY, 0.8);
        }
        
        // 重置视图
        function resetView() {
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            drawImage();
            updateZoomLevel();
        }
        
        // 清除当前多边形
        function clearCurrentPolygon() {
            currentPolygon = [];
            drawImage();
        }
        
        // 完成多边形绘制：弹出标签选择框，选择标签后才算完成
        async function finishPolygon() {
            if (currentPolygon.length >= 3) {
                try {
                    const tag = await showTagPicker();
                    if (!tag) {
                        // 取消或未选择标签，保留当前多边形以便继续编辑
                        return;
                    }

                    polygons.push({ points: [...currentPolygon], tag });
                } catch (e) {
                    console.error('Tag selection error:', e);
                }
            }
            currentPolygon = [];
            drawImage();
            updatePolygonCount();
        }
        
        // 检查点是否接近第一个点（用于闭合多边形）
        function isNearFirstPoint(x, y) {
            if (currentPolygon.length < 3) return false;

            const firstPointImg = currentPolygon[0];
            const firstPointCanvas = imageToCanvasCoords(firstPointImg.x, firstPointImg.y);
            const distance = Math.sqrt(Math.pow(x - firstPointCanvas.x, 2) + Math.pow(y - firstPointCanvas.y, 2));
            return distance < 10; // 10像素内的距离认为是闭合
        }
        
        // 更新多边形计数显示
        function updatePolygonCount() {
            document.getElementById('polygonCount').textContent = polygons.length;
        }
        
        // 更新缩放级别显示
        function updateZoomLevel() {
            document.getElementById('zoomLevel').textContent = Math.round(scale * 100) + '%';
        }

        // 点是否在多边形内（画布坐标）。使用射线法。
        function pointInPolygon(x, y, polyPoints) {
            let inside = false;
            for (let i = 0, j = polyPoints.length - 1; i < polyPoints.length; j = i++) {
                const xi = polyPoints[i].x, yi = polyPoints[i].y;
                const xj = polyPoints[j].x, yj = polyPoints[j].y;
                const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi + 1e-12) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // 右键时在多边形内显示内建菜单（目前只有删除）
        function showPolygonContextMenu(e) {
            try {
                const rect = canvas.getBoundingClientRect();
                const cx = e.clientX - rect.left;
                const cy = e.clientY - rect.top;

                // 找到最上层（最后绘制）的多边形
                let foundIndex = -1;
                for (let i = polygons.length - 1; i >= 0; i--) {
                    const poly = polygons[i];
                    // 将多边形顶点转换为画布坐标
                    const canvasPts = poly.points.map(p => imageToCanvasCoords(p.x, p.y));
                    if (pointInPolygon(cx, cy, canvasPts)) { foundIndex = i; break; }
                }

                // 移除已有菜单
                const prev = document.getElementById('polygonContextMenu');
                if (prev) prev.remove();

                if (foundIndex === -1) return; // 未点击到多边形

                const menu = document.createElement('div');
                menu.id = 'polygonContextMenu';
                menu.style.position = 'fixed';
                menu.style.left = e.clientX + 'px';
                menu.style.top = e.clientY + 'px';
                menu.style.background = '#fff';
                menu.style.border = '1px solid rgba(0,0,0,0.12)';
                menu.style.borderRadius = '4px';
                menu.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
                menu.style.zIndex = 2000;
                menu.style.padding = '6px';

                const del = document.createElement('div');
                del.textContent = '删除';
                del.style.cursor = 'pointer';
                del.style.padding = '4px 8px';
                del.addEventListener('click', function() {
                    polygons.splice(foundIndex, 1);
                    updatePolygonCount();
                    drawImage();
                    menu.remove();
                });

                menu.appendChild(del);
                document.body.appendChild(menu);

                // 点击任意处关闭菜单
                const onDocClick = function(ev) {
                    if (!menu.contains(ev.target)) { menu.remove(); document.removeEventListener('mousedown', onDocClick); }
                };
                document.addEventListener('mousedown', onDocClick);
            } catch (err) {
                console.error('showPolygonContextMenu error', err);
            }
        }
        
        // 保存标注并加载新任务
        function saveAndLoadNew() {
            if (!currentTaskId) {
                console.warn('No current task ID available');
                return;
            }
            
            console.log('Saving annotation for task:', currentTaskId);
            
            // 验证多边形数据
            if (polygons.length === 0) {
                console.warn('No polygons to save');
                // 即使没有多边形也允许保存空标注
            }
            
            // 准备注释数据
            let annotationData;
            try {
                    annotationData = {
                    taskId: currentTaskId,
                    // polygons 存储为 { points: [...], tag }
                    polygons: polygons.map(polygon => ({
                        tag: polygon.tag,
                        points: polygon.points.map(point => ({
                            x: Math.round(point.x * 100) / 100,
                            y: Math.round(point.y * 100) / 100
                        }))
                    }))
                };
                
                console.log('Prepared annotation data:', annotationData);
            } catch (error) {
                console.error('Error preparing annotation data:', error);
                alert('准备标注数据时出错: ' + error.message);
                return;
            }
            
            // 显示保存中状态
            hideLoadingShowMessage(`
                <div class="d-flex justify-content-center align-items-center" style="height: 100vh;">
                    <div>
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">保存中...</span>
                        </div>
                        <p class="mt-2">正在保存标注数据...</p>
                    </div>
                </div>
            `);
            
            // 添加超时处理
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('保存请求超时')), 10000);
            });
            
            Promise.race([
                fetch('/api/annotations/save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: JSON.stringify(annotationData)
                }),
                timeoutPromise
            ])
            .then(response => {
                console.log('Save response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                return response.json();
            })
            .then(data => {
                console.log('Save response data:', data);
                
                    if (data.success) {
                    console.log('Annotation saved successfully');
                    // 重置状态并加载新任务（先刷新缩略图以立即反映刚保存的标注）
                    polygons = [];
                    currentPolygon = [];
                    updatePolygonCount();
                    try { loadAnnotatorThumbnails(); } catch(_) {}
                    loadRandomTask();
                } else {
                    console.error('Save failed:', data.error);
                    hideLoadingShowMessage(`
                        <div class="text-center text-danger">
                            <i class="fas fa-save" style="font-size: 3rem;"></i>
                            <p class="mt-3">保存失败: ${data.error || '未知错误'}</p>
                            <button class="btn btn-secondary mt-2" onclick="history.back()">返回</button>
                            <button class="btn btn-primary mt-2 ms-2" onclick="saveAndLoadNew()">重试保存</button>
                        </div>
                    `);
                }
            })
            .catch(error => {
                console.error('Error saving annotation:', error);
                
                let errorMessage = error.message;
                if (errorMessage.includes('Failed to fetch')) {
                    errorMessage = '无法连接到服务器，请检查网络连接';
                } else if (errorMessage.includes('timeout')) {
                    errorMessage = '请求超时，请检查网络连接';
                }
                
                hideLoadingShowMessage(`
                    <div class="text-center text-danger">
                        <i class="fas fa-exclamation-triangle" style="font-size: 3rem;"></i>
                        <p class="mt-3">保存失败: ${errorMessage}</p>
                        <button class="btn btn-secondary mt-2" onclick="history.back()">返回</button>
                        <button class="btn btn-primary mt-2 ms-2" onclick="saveAndLoadNew()">重试保存</button>
                    </div>
                `);
            });
        }
        
        // 将画布坐标转换为图片坐标
        function canvasToImageCoords(canvasX, canvasY) {
            if (!currentImage) return {x: 0, y: 0};
            
            const imageWidth = currentImage.width * scale;
            const imageHeight = currentImage.height * scale;
            const imageX = (canvas.width - imageWidth) / 2 + offsetX;
            const imageY = (canvas.height - imageHeight) / 2 + offsetY;
            
            const x = ((canvasX - imageX) / scale);
            const y = ((canvasY - imageY) / scale);
            
            return {x, y};
        }
        
        // 将图片坐标转换为画布坐标
        function imageToCanvasCoords(imageX, imageY) {
            if (!currentImage) return {x: 0, y: 0};
            
            const imageWidth = currentImage.width * scale;
            const imageHeight = currentImage.height * scale;
            const imageXPos = (canvas.width - imageWidth) / 2 + offsetX;
            const imageYPos = (canvas.height - imageHeight) / 2 + offsetY;
            
            const x = imageXPos + (imageX * scale);
            const y = imageYPos + (imageY * scale);
            
            return {x, y};
        }

        // ----- 标签支持相关 -----
        let availableTags = [];

        async function loadAvailableTags() {
            try {
                const res = await fetch('/api/tags');
                const data = await res.json();
                if (data.success) availableTags = data.data.map(t => t.name);
            } catch (e) {
                console.warn('Failed to load tags:', e);
            }
        }

        // 显示标签选择弹窗，返回 Promise resolved with tag name 或 null
        function showTagPicker() {
            return new Promise((resolve) => {
                // 创建简单的 modal 内容
                const modalId = 'tagPickerModal';
                let modal = document.getElementById(modalId);
                if (!modal) {
                    modal = document.createElement('div');
                    modal.id = modalId;
                    modal.className = 'modal show';
                    modal.style.display = 'none';
                    modal.innerHTML = `
                        <div class="modal-dialog modal-sm" role="document">
                            <div class="modal-content">
                                <div class="modal-header"><h5 class="modal-title">选择标签</h5></div>
                                <div class="modal-body" id="tagPickerBody"></div>
                                <div class="modal-footer">
                                    <button id="tagPickerCancel" class="btn btn-secondary">取消</button>
                                </div>
                            </div>
                        </div>`;
                    document.body.appendChild(modal);
                }

                const body = modal.querySelector('#tagPickerBody');
                body.innerHTML = '';

                if (!availableTags || availableTags.length === 0) {
                    body.innerHTML = '<div class="text-muted">暂无标签，请到管理页面添加。</div>';
                } else {
                    availableTags.forEach(tag => {
                        const btn = document.createElement('button');
                        btn.className = 'btn btn-outline-primary m-1';
                        btn.textContent = tag;
                        btn.addEventListener('click', () => {
                            hideModal();
                            resolve(tag);
                        });
                        body.appendChild(btn);
                    });
                }

                const cancelBtn = modal.querySelector('#tagPickerCancel');
                cancelBtn.onclick = () => { hideModal(); resolve(null); };

                function hideModal() {
                    modal.style.display = 'none';
                }

                modal.style.display = 'block';
            });
        }
    </script>
</body>
</html>